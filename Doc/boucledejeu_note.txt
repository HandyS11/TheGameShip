Processus ouverture programme

Alloue la mémoire
Charge les instructions

pile d'execution = instruction
thread(=unité d'exécution) => pointe sur l'instruction en cours et passe à la prochaine

pour le timer créer un autre thread 

le thread est à l'intérieur du processus donc partage même zone mémoire, à la différence de deux processus qui ont deux zones mémoire.

thread principale est le seul qui doit modifier/actualiser interface graphique.

//FZERO
while(true){
	mise a jour du jeu();
}

Vitesse du jeu = Vitesse du processeur (pas fou aujourd'hui)

D'où l'intérêt des fps, toute les secondes actualise le jeu.

while(true){
	sleep(1000);
	mise a jour du jeu();
}

1000ms = 1 fps

Le sleep mets en pause tout le thread d'où l'intérêt de le faire dans un autre thread.

Thread en java doit hériter de la classe thread.
Il faudra redéfinir la méthode run() dans la fille.

Boucledejeu b=new Boucledejeu();
b.start() et non b.run();

Il existe aussi l'interface runable si on peut pas hériter de thread. mais pas de méthode start() !
Thread b=new Thread(new Boucledejeu());
b.start();

Il faut mettre dans run(), c'est un beep() qui va notifier toute les classes abonner. (aka observateur)

Il faut que l'appel le fasse dans le thread principale et non le tread de la boucle. Donc il faut les envoyer d'une manière ou d'une autre dans le thread principale.Il faut donc faire un Plateform.runlater(runable); (celui du thread principale)

Point d'extendabiliter sur boucle de jeu pour différente vitesse

Plateform.runlater(()->{
	-------------;
	----------;
});
